"""WireGuard system service for managing local VPS interface.

This service manages the WireGuard interface on the VPS itself,
allowing remote MikroTik devices to connect as peers.
"""

import logging
import os
import shutil
import subprocess
from pathlib import Path
from uuid import UUID

from sqlalchemy.orm import Session

from app.models.wireguard import WireGuardPeerStatus, WireGuardServer, WireGuardPeer
from app.services.wireguard_crypto import decrypt_private_key

logger = logging.getLogger(__name__)

# Default WireGuard config directory
WG_CONFIG_DIR = Path(os.environ.get("WIREGUARD_CONFIG_DIR", "/etc/wireguard"))


class WireGuardSystemService:
    """Service for managing WireGuard interface on the local system."""

    @staticmethod
    def _command_prefix() -> list[str]:
        """Optional command prefix for host netns access from containers."""
        use_nsenter = os.environ.get("WIREGUARD_USE_NSENTER", "").lower() in {"1", "true", "yes"}
        if use_nsenter and shutil.which("nsenter"):
            return ["nsenter", "-t", "1", "-n"]
        return []

    @staticmethod
    def generate_config(db: Session, server_id: UUID) -> str:
        """Generate wg-quick configuration file content.

        Args:
            db: Database session
            server_id: WireGuard server ID

        Returns:
            Complete wg-quick configuration file content
        """
        server = db.query(WireGuardServer).filter(WireGuardServer.id == server_id).first()
        if not server:
            raise ValueError(f"Server {server_id} not found")

        if not server.private_key:
            raise ValueError("Server has no private key - regenerate keys first")

        # Decrypt private key
        try:
            private_key = decrypt_private_key(server.private_key)
        except Exception as e:
            raise ValueError(f"Failed to decrypt server private key: {e}")

        # Build [Interface] section
        vpn_address = server.vpn_address
        if not vpn_address or str(vpn_address).strip().lower() == "none":
            vpn_address = "10.10.0.1/24"
        address_values = [vpn_address]
        vpn_address_v6 = server.vpn_address_v6
        if vpn_address_v6 and str(vpn_address_v6).strip().lower() != "none":
            address_values.append(vpn_address_v6)
        address_values = [
            addr
            for addr in address_values
            if addr and str(addr).strip().lower() != "none"
        ]
        lines = [
            "# WireGuard configuration generated by DotMac SM",
            f"# Server: {server.name}",
            "",
            "[Interface]",
            f"PrivateKey = {private_key}",
            f"Address = {', '.join(address_values)}",
            f"ListenPort = {server.listen_port}",
        ]

        if server.mtu:
            lines.append(f"MTU = {server.mtu}")

        # Add PostUp/PostDown for enabling IP forwarding
        lines.extend([
            "",
            "# Enable IP forwarding",
            "PostUp = sysctl -w net.ipv4.ip_forward=1",
            "PostUp = sysctl -w net.ipv6.conf.all.forwarding=1",
            "PostDown = sysctl -w net.ipv4.ip_forward=0",
            "PostDown = sysctl -w net.ipv6.conf.all.forwarding=0",
        ])

        routes = []
        if server.metadata_:
            routes = server.metadata_.get("routes") or []

        if routes:
            lines.append("")
            lines.append("# Static routes via WireGuard interface")
            for cidr in routes:
                if ":" in cidr:
                    lines.append(f"PostUp = ip -6 route replace {cidr} dev %i")
                    lines.append(f"PostDown = ip -6 route del {cidr} dev %i || true")
                else:
                    lines.append(f"PostUp = ip route replace {cidr} dev %i")
                    lines.append(f"PostDown = ip route del {cidr} dev %i || true")

        # Get all active peers
        peers = (
            db.query(WireGuardPeer)
            .filter(
                WireGuardPeer.server_id == server_id,
                WireGuardPeer.status == WireGuardPeerStatus.active,
            )
            .all()
        )

        for peer in peers:
            lines.extend([
                "",
                f"# Peer: {peer.name}",
                "[Peer]",
                f"PublicKey = {peer.public_key}",
            ])

            # Add preshared key if exists
            if peer.preshared_key:
                try:
                    psk = decrypt_private_key(peer.preshared_key)
                    lines.append(f"PresharedKey = {psk}")
                except Exception:
                    logger.warning(f"Failed to decrypt preshared key for peer {peer.id}")

            # Build AllowedIPs
            allowed_ips = []
            if peer.peer_address:
                # Add peer's VPN address
                if "/" not in peer.peer_address:
                    allowed_ips.append(f"{peer.peer_address}/32")
                else:
                    allowed_ips.append(peer.peer_address)
            if peer.peer_address_v6 and str(peer.peer_address_v6).strip().lower() != "none":
                if "/" not in peer.peer_address_v6:
                    allowed_ips.append(f"{peer.peer_address_v6}/128")
                else:
                    allowed_ips.append(peer.peer_address_v6)

            # Add any additional allowed IPs (e.g., LAN networks behind the peer)
            if peer.allowed_ips:
                allowed_ips.extend(
                    ip for ip in peer.allowed_ips if ip and str(ip).strip().lower() != "none"
                )

            if allowed_ips:
                lines.append(f"AllowedIPs = {', '.join(allowed_ips)}")

            # Persistent keepalive (usually not needed on server side, but include if set)
            if peer.persistent_keepalive and peer.persistent_keepalive > 0:
                lines.append(f"PersistentKeepalive = {peer.persistent_keepalive}")

        lines.append("")  # Trailing newline
        return "\n".join(lines)

    @staticmethod
    def get_config_path(server: WireGuardServer) -> Path:
        """Get the config file path for a server."""
        return WG_CONFIG_DIR / f"{server.interface_name}.conf"

    @staticmethod
    def write_config(db: Session, server_id: UUID) -> Path:
        """Write WireGuard configuration to disk.

        Args:
            db: Database session
            server_id: WireGuard server ID

        Returns:
            Path to the written config file
        """
        server = db.query(WireGuardServer).filter(WireGuardServer.id == server_id).first()
        if not server:
            raise ValueError(f"Server {server_id} not found")

        config_content = WireGuardSystemService.generate_config(db, server_id)
        config_path = WireGuardSystemService.get_config_path(server)

        # Ensure directory exists
        WG_CONFIG_DIR.mkdir(parents=True, exist_ok=True)

        # Write config with secure permissions (600)
        config_path.write_text(config_content)
        os.chmod(config_path, 0o600)

        logger.info(f"Wrote WireGuard config to {config_path}")
        return config_path

    @staticmethod
    def is_interface_up(interface_name: str) -> bool:
        """Check if a WireGuard interface is up."""
        try:
            prefix = WireGuardSystemService._command_prefix()
            result = subprocess.run(
                prefix + ["wg", "show", interface_name],
                capture_output=True,
                text=True,
                timeout=5,
            )
            return result.returncode == 0
        except Exception:
            return False

    @staticmethod
    def bring_up_interface(interface_name: str) -> tuple[bool, str]:
        """Bring up a WireGuard interface using wg-quick.

        Returns:
            Tuple of (success, message)
        """
        try:
            prefix = WireGuardSystemService._command_prefix()
            result = subprocess.run(
                prefix + ["wg-quick", "up", interface_name],
                capture_output=True,
                text=True,
                timeout=30,
            )
            if result.returncode == 0:
                return True, f"Interface {interface_name} is up"
            else:
                return False, f"Failed to bring up interface: {result.stderr}"
        except subprocess.TimeoutExpired:
            return False, "Command timed out"
        except FileNotFoundError:
            return False, "wg-quick not found - is WireGuard installed?"
        except Exception as e:
            return False, str(e)

    @staticmethod
    def bring_down_interface(interface_name: str) -> tuple[bool, str]:
        """Bring down a WireGuard interface using wg-quick.

        Returns:
            Tuple of (success, message)
        """
        try:
            prefix = WireGuardSystemService._command_prefix()
            result = subprocess.run(
                prefix + ["wg-quick", "down", interface_name],
                capture_output=True,
                text=True,
                timeout=30,
            )
            if result.returncode == 0:
                return True, f"Interface {interface_name} is down"
            else:
                # Interface might not be up, which is fine
                if "is not a WireGuard interface" in result.stderr:
                    return True, f"Interface {interface_name} was not up"
                return False, f"Failed to bring down interface: {result.stderr}"
        except subprocess.TimeoutExpired:
            return False, "Command timed out"
        except FileNotFoundError:
            return False, "wg-quick not found - is WireGuard installed?"
        except Exception as e:
            return False, str(e)

    @staticmethod
    def reload_interface(interface_name: str) -> tuple[bool, str]:
        """Reload WireGuard interface by syncing config.

        Uses 'wg syncconf' for seamless updates without dropping connections.

        Returns:
            Tuple of (success, message)
        """
        config_path = WG_CONFIG_DIR / f"{interface_name}.conf"

        if not config_path.exists():
            return False, f"Config file not found: {config_path}"

        try:
            prefix = WireGuardSystemService._command_prefix()
            # Use wg-quick strip to get the wg-compatible config format
            strip_result = subprocess.run(
                prefix + ["wg-quick", "strip", interface_name],
                capture_output=True,
                text=True,
                timeout=5,
            )

            if strip_result.returncode != 0:
                return False, f"Failed to parse config: {strip_result.stderr}"

            # Sync the configuration
            sync_result = subprocess.run(
                prefix + ["wg", "syncconf", interface_name, "/dev/stdin"],
                input=strip_result.stdout,
                capture_output=True,
                text=True,
                timeout=10,
            )

            if sync_result.returncode == 0:
                return True, f"Interface {interface_name} configuration synced"
            else:
                return False, f"Failed to sync config: {sync_result.stderr}"

        except subprocess.TimeoutExpired:
            return False, "Command timed out"
        except FileNotFoundError:
            return False, "wg/wg-quick not found - is WireGuard installed?"
        except Exception as e:
            return False, str(e)

    @staticmethod
    def deploy_server(db: Session, server_id: UUID) -> tuple[bool, str]:
        """Deploy or update WireGuard server configuration.

        This is the main entry point for deploying changes:
        1. Writes config to disk
        2. If interface is up, reloads it
        3. If interface is down and server is active, brings it up

        Returns:
            Tuple of (success, message)
        """
        server = db.query(WireGuardServer).filter(WireGuardServer.id == server_id).first()
        if not server:
            return False, f"Server {server_id} not found"

        if not server.public_key:
            return False, "Server has no keys - regenerate keys first"
        if not server.vpn_address or str(server.vpn_address).strip().lower() == "none":
            server.vpn_address = "10.10.0.1/24"
            db.commit()
            db.refresh(server)

        try:
            # Write config to disk
            WireGuardSystemService.write_config(db, server_id)
        except Exception as e:
            return False, f"Failed to write config: {e}"

        interface_name = server.interface_name
        is_up = WireGuardSystemService.is_interface_up(interface_name)

        if is_up:
            # Interface is up - reload config
            success, msg = WireGuardSystemService.reload_interface(interface_name)
            if success:
                logger.info(f"Reloaded WireGuard interface {interface_name}")
            return success, msg
        elif server.is_active:
            # Interface is down but should be up - bring it up
            success, msg = WireGuardSystemService.bring_up_interface(interface_name)
            if success:
                logger.info(f"Started WireGuard interface {interface_name}")
            return success, msg
        else:
            # Server is inactive, config is written but interface stays down
            return True, f"Config written to {WireGuardSystemService.get_config_path(server)}"

    @staticmethod
    def undeploy_server(db: Session, server_id: UUID) -> tuple[bool, str]:
        """Bring down WireGuard interface and optionally remove config.

        Returns:
            Tuple of (success, message)
        """
        server = db.query(WireGuardServer).filter(WireGuardServer.id == server_id).first()
        if not server:
            return False, f"Server {server_id} not found"

        interface_name = server.interface_name

        if WireGuardSystemService.is_interface_up(interface_name):
            success, msg = WireGuardSystemService.bring_down_interface(interface_name)
            if not success:
                return success, msg

        return True, f"Interface {interface_name} is down"

    @staticmethod
    def get_interface_status(interface_name: str) -> dict:
        """Get detailed status of a WireGuard interface.

        Returns:
            Dict with interface status and peer info
        """
        status = {
            "interface": interface_name,
            "is_up": False,
            "public_key": None,
            "listen_port": None,
            "peers": [],
        }

        try:
            prefix = WireGuardSystemService._command_prefix()
            result = subprocess.run(
                prefix + ["wg", "show", interface_name, "dump"],
                capture_output=True,
                text=True,
                timeout=5,
            )

            if result.returncode != 0:
                return status

            status["is_up"] = True
            lines = result.stdout.strip().split("\n")

            if lines:
                # First line is interface info
                parts = lines[0].split("\t")
                if len(parts) >= 3:
                    status["public_key"] = parts[1]
                    status["listen_port"] = int(parts[2]) if parts[2] else None

                # Remaining lines are peers
                for line in lines[1:]:
                    parts = line.split("\t")
                    if len(parts) >= 8:
                        peer = {
                            "public_key": parts[0],
                            "preshared_key": parts[1] if parts[1] != "(none)" else None,
                            "endpoint": parts[2] if parts[2] != "(none)" else None,
                            "allowed_ips": parts[3].split(",") if parts[3] else [],
                            "latest_handshake": int(parts[4]) if parts[4] != "0" else None,
                            "rx_bytes": int(parts[5]),
                            "tx_bytes": int(parts[6]),
                            "persistent_keepalive": int(parts[7]) if parts[7] != "off" else 0,
                        }
                        status["peers"].append(peer)

        except Exception as e:
            logger.error(f"Failed to get interface status: {e}")

        return status

    @staticmethod
    def enable_systemd_service(interface_name: str) -> tuple[bool, str]:
        """Enable WireGuard interface to start on boot via systemd.

        Returns:
            Tuple of (success, message)
        """
        try:
            result = subprocess.run(
                ["systemctl", "enable", f"wg-quick@{interface_name}"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                return True, f"Enabled wg-quick@{interface_name} service"
            else:
                return False, f"Failed to enable service: {result.stderr}"
        except Exception as e:
            return False, str(e)

    @staticmethod
    def disable_systemd_service(interface_name: str) -> tuple[bool, str]:
        """Disable WireGuard interface from starting on boot.

        Returns:
            Tuple of (success, message)
        """
        try:
            result = subprocess.run(
                ["systemctl", "disable", f"wg-quick@{interface_name}"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                return True, f"Disabled wg-quick@{interface_name} service"
            else:
                return False, f"Failed to disable service: {result.stderr}"
        except Exception as e:
            return False, str(e)
