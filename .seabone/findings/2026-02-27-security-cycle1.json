[
  {
    "id": "security-c1-1",
    "severity": "critical",
    "category": "security",
    "file": "app/services/integration_hooks.py",
    "line": 415,
    "issue": "CLI integration hooks execute user-configurable shell commands with `shell=True`, enabling remote code execution for any admin who can create or edit a hook.",
    "task": "Replace `subprocess.run(command, shell=True, ...)` with `subprocess.run(shlex.split(command), shell=False, ...)` and validate that the resulting argv[0] is an absolute path to an allowlisted binary.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-2",
    "severity": "critical",
    "category": "security",
    "file": "app/api/auth.py",
    "line": 27,
    "issue": "All 21 endpoints for user-credentials, MFA methods, sessions, and API keys (lines 27–281) have no authentication or permission checks, allowing unauthenticated creation, enumeration, modification, and deletion of credentials for any subscriber.",
    "task": "Add `dependencies=[Depends(require_permission('auth:admin'))]` to every router decorator in app/api/auth.py, or split into a subscriber-self-service path that enforces the calling subscriber's identity.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-3",
    "severity": "high",
    "category": "security",
    "file": "app/services/credential_crypto.py",
    "line": 54,
    "issue": "When `CREDENTIAL_ENCRYPTION_KEY` is not set, `encrypt_credential()` silently stores credentials with a `plain:` prefix instead of refusing, so NAS shared secrets and API tokens land in the database unencrypted with no deployment-time failure.",
    "task": "Raise a `RuntimeError` (or `ValueError`) in `_load_encryption_key()` when the key is absent rather than returning `None`, so misconfigured deployments fail loudly at startup rather than silently degrading security.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-4",
    "severity": "high",
    "category": "security",
    "file": "app/services/wireguard.py",
    "line": 1308,
    "issue": "`ssl_verify=False` is set on all RouterOS API pool connections (also in web_vpn_servers.py:642), disabling TLS certificate validation and exposing RouterOS credentials to man-in-the-middle interception.",
    "task": "Remove `ssl_verify=False` from all `RouterOsApiPool` calls and, if self-signed certs are in use, add a configurable CA bundle path rather than disabling verification globally.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-5",
    "severity": "high",
    "category": "security",
    "file": "app/api/settings.py",
    "line": 26,
    "issue": "The `PUT /settings/gis/{key}` (line 26) and `PUT /settings/geocoding/{key}` (line 65) endpoints only require `require_user_auth` (via main.py router-level dependency) rather than `require_permission('system:settings:write')`, allowing any authenticated user to overwrite geocoding and GIS service credentials stored in DomainSetting.",
    "task": "Add `dependencies=[Depends(require_permission('system:settings:write'))]` to both PUT endpoint decorators in app/api/settings.py to enforce write permission beyond basic authentication.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-6",
    "severity": "high",
    "category": "security",
    "file": "app/services/avatar.py",
    "line": 54,
    "issue": "In `delete_avatar()`, the filename is extracted using a single `.replace()` call on the URL prefix, making it possible to craft an avatar URL that resolves to a path outside the avatar upload directory and delete arbitrary server files.",
    "task": "Replace the prefix-stripping logic with `Path(file_path).resolve().relative_to(Path(settings.avatar_upload_dir).resolve())` and raise an error if the path escapes the expected directory.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-7",
    "severity": "high",
    "category": "security",
    "file": "app/services/enforcement.py",
    "line": 742,
    "issue": "RADIUS table names (`radcheck`, `radreply`, `radusergroup`) are interpolated directly into SQL strings via f-strings (3 occurrences with `# noqa: S608`); if the configuration source is tampered with, this becomes exploitable SQL injection.",
    "task": "Validate each table name string against a hard-coded allowlist (e.g., `ALLOWED_RADIUS_TABLES = frozenset({...})`) before interpolating it into the SQL template, and raise `ValueError` on any unexpected name.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-8",
    "severity": "high",
    "category": "security",
    "file": "app/api/auth_flow.py",
    "line": 48,
    "issue": "The `POST /auth/login` endpoint has no IP-based rate limiting; per-account lockout (5 attempts, 15 min) does not prevent distributed password-spraying across many subscriber accounts.",
    "task": "Apply a sliding-window rate limiter (e.g., via slowapi or a Redis-backed counter) on `POST /auth/login` keyed by client IP, limiting to a configurable threshold (e.g., 20 req/min) before the service layer is reached.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-9",
    "severity": "high",
    "category": "security",
    "file": "app/services/radius.py",
    "line": 298,
    "issue": "Eight RADIUS SQL statements interpolate configuration-sourced table names (`radcheck`, `radreply`, `radusergroup`, `nas_table`) via f-strings; compromised config values would enable SQL injection.",
    "task": "Add an allowlist validation function for RADIUS table names and call it once when loading the RADIUS configuration, raising a clear error for any name that does not match the expected pattern.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-10",
    "severity": "high",
    "category": "security",
    "file": "app/services/secrets.py",
    "line": 39,
    "issue": "In `resolve_openbao_ref()`, the `mount` and `path` components parsed from a user-supplied `bao://` reference are concatenated directly into the request URL without character validation, allowing path traversal within the Vault/OpenBao namespace.",
    "task": "After parsing, validate that `mount` and `path` only contain alphanumeric characters, hyphens, underscores, and forward-slashes (reject `..`, `%2e`, etc.) before constructing the URL.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-11",
    "severity": "high",
    "category": "security",
    "file": "app/services/web_integrations.py",
    "line": 268,
    "issue": "`_probe_embedded_url_health()` passes the connector's `base_url` directly to `httpx.get()` without checking for RFC 1918 / link-local addresses, allowing SSRF attacks against internal services and cloud metadata endpoints.",
    "task": "Before making the HTTP request, resolve the target hostname and verify it is not in private/loopback/link-local ranges (127.x, 10.x, 172.16-31.x, 192.168.x, 169.254.x); raise an error or return a health-check failure for blocked addresses.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-12",
    "severity": "high",
    "category": "security",
    "file": "app/services/file_storage.py",
    "line": 360,
    "issue": "`stream_file()` uses `StoredFile.legacy_local_path` directly from the database to open and stream file contents without validating the path is within a permitted directory, enabling arbitrary file read if the DB value is manipulated.",
    "task": "After resolving the path with `.resolve()`, assert it is a child of a configured base upload directory using `path.relative_to(base_dir)` and raise `PermissionError` if the assertion fails.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-13",
    "severity": "high",
    "category": "security",
    "file": "app/web/admin/system.py",
    "line": 623,
    "issue": "The export-job download endpoint reads `file_path` from the job record stored in DomainSetting and passes it to `FileResponse()` without validating it is within an expected export directory, allowing arbitrary file download.",
    "task": "Define a `EXPORT_JOBS_BASE_DIR` constant and use `Path(file_path).resolve().relative_to(Path(EXPORT_JOBS_BASE_DIR).resolve())` to assert containment before serving the file.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-23",
    "severity": "high",
    "category": "security",
    "file": "app/tasks/webhooks.py",
    "line": 103,
    "issue": "Webhook delivery task sends HTTP POST to `endpoint.url` (stored in the database) without validating the destination against RFC 1918 / link-local ranges, enabling SSRF against internal services (Redis, metadata endpoints, admin APIs) for any authenticated user who can create webhook endpoints and trigger events.",
    "task": "In `deliver_webhook()`, resolve the hostname from `endpoint.url` before making the HTTP request and reject addresses in 127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, and 169.254.0.0/16; also enforce `https://` scheme for production endpoints.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-14",
    "severity": "medium",
    "category": "security",
    "file": "app/config.py",
    "line": 48,
    "issue": "S3-compatible object storage defaults to well-known MinIO credentials (`minioadmin` / `minioadmin`) when `S3_ACCESS_KEY` or `S3_SECRET_KEY` environment variables are absent, granting full storage access on unset deployments.",
    "task": "Remove the hardcoded default credential strings from `Settings`; raise a `ValueError` at startup (or use `...` as the Pydantic field default) to force explicit configuration of object storage credentials.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-15",
    "severity": "medium",
    "category": "security",
    "file": "app/config.py",
    "line": 30,
    "issue": "The Splynx MySQL integration defaults to username `splynx` with an empty password when environment variables are unset, which may authenticate against a live database in misconfigured environments.",
    "task": "Remove the non-empty username default and replace the empty-password default with `None`; guard the MySQL connection code to refuse connecting when password is `None`.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-16",
    "severity": "medium",
    "category": "security",
    "file": "app/services/auth_flow.py",
    "line": 108,
    "issue": "`_jwt_secret()` accepts any non-empty string as a JWT signing secret with no minimum-length enforcement, meaning a short or guessable value from the database or environment will silently be used.",
    "task": "After resolving the secret string, check `len(secret) >= 32` and raise an `HTTPException(status_code=500)` with an appropriate message if the secret is too short.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-17",
    "severity": "medium",
    "category": "security",
    "file": "app/services/auth_flow.py",
    "line": 577,
    "issue": "The login function checks the account lockout status _after_ verifying the password, so a locked account with a correct password returns HTTP 403 `Account locked` while a wrong password returns HTTP 401, enabling username/password enumeration.",
    "task": "Move the `locked_until` check to before the password verification block so both wrong-password and locked-account paths return the same HTTP status and message.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-18",
    "severity": "medium",
    "category": "security",
    "file": "app/services/web_network_olts.py",
    "line": 190,
    "issue": "The backup-file path containment check uses a string `startswith()` comparison (`str(candidate).startswith(str(base))`), which can be bypassed with sibling directory names (e.g., `/app/backups_evil`) on some filesystems.",
    "task": "Replace the `startswith` check with `candidate.relative_to(base)` inside a try/except `ValueError` block to use Python's guaranteed path-containment semantics.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-19",
    "severity": "medium",
    "category": "security",
    "file": "app/services/sms.py",
    "line": 192,
    "issue": "The SMS webhook sender posts to `sms_webhook_url` (from database settings) via `httpx.post()` without validating the destination host, allowing SSRF to internal services or cloud metadata endpoints if the setting is tampered with.",
    "task": "Extract and resolve the hostname from `webhook_url` before making the request, reject RFC 1918 / link-local addresses, and enforce an `https://` scheme requirement for production environments.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-20",
    "severity": "medium",
    "category": "security",
    "file": "app/config.py",
    "line": 47,
    "issue": "The S3 endpoint and internal monitoring services (VictoriaMetrics, etc.) default to plain `http://` URLs, meaning traffic between application and storage/metrics backends is unencrypted and susceptible to interception on the network.",
    "task": "Update internal service URL defaults to use `https://` and document that HTTP should only be used for local loopback (`127.0.0.1`) integrations; add a startup warning when non-loopback HTTP URLs are detected.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-21",
    "severity": "medium",
    "category": "security",
    "file": "app/services/wireguard.py",
    "line": 1307,
    "issue": "`plaintext_login=True` is set on all RouterOS API pool connections (also in provisioning_adapters.py:139 and poller/mikrotik_poller.py:95), transmitting RouterOS credentials in cleartext which is especially dangerous combined with `ssl_verify=False`.",
    "task": "Set `plaintext_login=False` to use the RouterOS challenge–response login protocol; if legacy devices require plaintext, make it a per-device opt-in setting and document the security trade-off.",
    "auto_fixable": false,
    "effort": "medium"
  },
  {
    "id": "security-c1-24",
    "severity": "medium",
    "category": "security",
    "file": "app/services/nextcloud_talk.py",
    "line": 125,
    "issue": "The Nextcloud Talk client constructs HTTP requests using a `base_url` supplied in the request payload (via `app/api/nextcloud_talk.py`) without validating the hostname against RFC 1918 / link-local ranges, enabling any authenticated user to probe internal services via SSRF.",
    "task": "In `resolve_talk_client()`, parse the `base_url` hostname and reject RFC 1918, loopback, and link-local addresses before returning the client; also enforce an `https://` scheme unless explicitly configured to allow HTTP for development.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-25",
    "severity": "medium",
    "category": "security",
    "file": "app/services/auth_dependencies.py",
    "line": 109,
    "issue": "In `require_audit_auth()`, any valid and active API key (regardless of its assigned scopes) grants full access to audit endpoints — including reading and deleting audit events — because the `audit:read` scope check applies only to JWT tokens, not API keys.",
    "task": "After locating the API key record (line 117), check that `api_key.scopes` (or equivalent field) contains `audit:read` or `audit:*` before returning successfully; raise `HTTPException(status_code=403)` if the key lacks the required scope.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-26",
    "severity": "medium",
    "category": "security",
    "file": "templates/public/legal/document.html",
    "line": 108,
    "issue": "Legal document body (`document.content`) is rendered with `| safe`, bypassing Jinja2 auto-escaping; any admin who can create or edit a legal document (Terms of Service, Privacy Policy) can inject arbitrary HTML/JavaScript that executes in every visitor's browser on a public page.",
    "task": "Before storing legal document content, sanitize it with a server-side HTML allowlist library (e.g., `bleach` or `nh3`) that permits safe formatting tags (p, h2, ul, li, strong, em, a[href]) but strips all JavaScript, event handlers, and dangerous attributes.",
    "auto_fixable": false,
    "effort": "medium"
  },
  {
    "id": "security-c1-27",
    "severity": "medium",
    "category": "security",
    "file": "templates/customer/contracts/sign.html",
    "line": 26,
    "issue": "Contract template HTML (`contract_html`) is rendered with `| safe` on the subscriber-facing contract signing page; `app/services/contracts.py:180` passes `contract_template.content` directly without sanitization despite a security comment claiming it must be sanitized.",
    "task": "In `ContractSignatures.get_contract_context()` (app/services/contracts.py:180), pass `contract_html` through a server-side HTML sanitizer (e.g., `bleach.clean()` or `nh3.clean()`) before returning it, enforcing a strict allowlist of permitted tags and attributes.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-28",
    "severity": "medium",
    "category": "security",
    "file": "app/main.py",
    "line": 406,
    "issue": "The Prometheus `/metrics` endpoint is publicly accessible without any authentication, exposing internal system metrics (request rates, error counts, DB pool utilisation, memory usage) that aid an attacker in fingerprinting the application.",
    "task": "Protect the `/metrics` endpoint with at minimum a bearer-token or HTTP Basic auth check; consider serving metrics on a separate internal port (e.g., 9090) accessible only from the monitoring subnet, or add an IP-allowlist middleware guard.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-22",
    "severity": "low",
    "category": "security",
    "file": "app/services/radius.py",
    "line": 298,
    "issue": "Ten `# noqa: S608` comments in radius.py (8 instances) and enforcement.py (3 instances) suppress SQL-injection linting warnings on dynamic table-name queries without any inline rationale or reference to a tracking issue.",
    "task": "Add an inline comment on each suppression explaining that table names come from internal configuration only (not user input) and reference the tracking issue for the allowlist fix (security-c1-7 / security-c1-9).",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-29",
    "severity": "low",
    "category": "security",
    "file": "app/api/wireguard.py",
    "line": 246,
    "issue": "The `GET /wireguard/peers/{peer_id}/config/download` and `/mikrotik-script/download` endpoints return WireGuard configuration files (including private keys) for any peer UUID without verifying that the requesting user owns or has been granted access to that peer.",
    "task": "In `download_peer_config()` and `download_mikrotik_script()`, after fetching the peer record, assert that the caller's `subscriber_id` matches `peer.subscriber_id` or that the caller holds an operator role; return HTTP 403 if the check fails.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-31",
    "severity": "high",
    "category": "security",
    "file": "app/web/auth/routes.py",
    "line": 19,
    "issue": "The web form login endpoints for admin (`POST /auth/login`), customer portal (`POST /portal/auth/login`), and reseller portal (`POST /reseller/auth/login`) have no IP-based rate limiting, allowing unlimited password-spraying and brute-force attacks via the HTML form interface despite the API JSON login (`POST /api/v1/auth/login`) being protected with `@limiter.limit('20/minute')`.",
    "task": "Import and apply slowapi `@limiter.limit('20/minute')` to the POST login handlers in `app/web/auth/routes.py`, `app/web/customer/auth.py`, and `app/web/reseller/auth.py`, using the same `limiter` instance from `app/api/auth_flow.py` or creating a shared module-level `Limiter(key_func=get_remote_address)`.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "security-c1-32",
    "severity": "high",
    "category": "security",
    "file": "app/services/wireguard_system.py",
    "line": 173,
    "issue": "`get_config_path()` constructs the WireGuard config file path as `WG_CONFIG_DIR / f\"{server.interface_name}.conf\"` with no character validation on `interface_name`; an admin can set the field to a path-traversal string (e.g. `../../etc/cron.d/backdoor`) to write arbitrary files outside `/etc/wireguard/` when the server is deployed.",
    "task": "In `WireGuardServerCreate` and `WireGuardServerUpdate` schemas (`app/schemas/wireguard.py`), add a `pattern='^[A-Za-z][A-Za-z0-9_-]{0,14}$'` constraint on `interface_name` matching Linux kernel interface naming rules; also add a `Path.relative_to()` containment assert in `get_config_path()` as a defence-in-depth check.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "security-c1-30",
    "severity": "medium",
    "category": "security",
    "file": "app/services/web_customer_auth.py",
    "line": 26,
    "issue": "`_safe_next()` in both `web_customer_auth.py` (line 26) and `web_auth.py` (line 33) validates redirect URLs only with `startswith('/')`, which allows protocol-relative URLs like `//evil.com` that browsers treat as `https://evil.com`, enabling open-redirect attacks after successful login or password reset.",
    "task": "Change the check to `next_url.startswith('/') and not next_url.startswith('//')` in both `_safe_next()` implementations to block protocol-relative open redirects.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "security-c1-33",
    "severity": "medium",
    "category": "security",
    "file": "app/web/auth/routes.py",
    "line": 63,
    "issue": "The `POST /auth/forgot-password` web route has no rate limiting, allowing an attacker to submit unlimited email addresses — enabling bulk password reset email spam and email-existence enumeration via response-time differences when no account is found.",
    "task": "Apply slowapi `@limiter.limit('5/minute')` to the `forgot_password_submit()` handler in `app/web/auth/routes.py`; also apply a similar limit to any API equivalent if it exists.",
    "auto_fixable": false,
    "effort": "trivial"
  },
  {
    "id": "security-c1-34",
    "severity": "low",
    "category": "security",
    "file": "app/services/avatar.py",
    "line": 14,
    "issue": "`validate_avatar()` checks `file.content_type` from the HTTP request header (caller-controlled) instead of inspecting actual file magic bytes; a user can upload arbitrary content (e.g. SVG with embedded script) by spoofing the `Content-Type: image/jpeg` header, bypassing the MIME-type allowlist.",
    "task": "After reading file content in `save_avatar()`, check the first 12 bytes against the known image magic byte signatures already defined in `app/services/file_upload.py:MAGIC_BYTES` (`.jpg`, `.png`, `.gif`, `.webp`) and reject the upload if the bytes do not match the declared content type.",
    "auto_fixable": true,
    "effort": "small"
  }
]
